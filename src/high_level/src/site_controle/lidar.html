<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <style>
    canvas { background: #111;
        width: 100vw;
        height: 100vh;
        display: block;
    }

    html, body {
    margin: 0;
    padding: 0;
    width: 100%;
    height: 100%;
    overflow: hidden; /* plus jamais de scrollbar */
    background: #111;
    }
  </style>
</head>
<body>

<canvas id="lidar"></canvas>

<script type="module">
const API = "";
async function fetchLidarInit() {
  const res = await fetch(`/api/lidar_init`);
  if (!res.ok) {
    throw new Error(`lidar_init failed: ${res.status}`);
  }
  const data = await res.json();
  return decodeBase64ToFloat32Array(data.xTheta);
}

const theta = await fetchLidarInit();

const canvas = document.getElementById("lidar");
function resizeCanvas() {
  canvas.width  = window.innerWidth;
  canvas.height = window.innerHeight;
}

resizeCanvas();
window.addEventListener("resize", resizeCanvas);

const ctx = canvas.getContext("2d");
const scale = 0.15; // mm → pixels

const proto = location.protocol === "https:" ? "wss" : "ws";
const ws = new WebSocket(proto + "://" + location.host + "/api/lidar/ws");
function decodeBase64ToInt16Array(b64) {
  const bin = atob(b64);
  const bytes = new Uint8Array(bin.length);
  for (let i = 0; i < bin.length; i++) bytes[i] = bin.charCodeAt(i);
  return new Int16Array(bytes.buffer);
}
function decodeBase64ToFloat32Array(b64) {
  const bin = atob(b64);
  const bytes = new Uint8Array(bin.length);
  for (let i = 0; i < bin.length; i++) bytes[i] = bin.charCodeAt(i);
  return new Float32Array(bytes.buffer);
}


// Precompute sin/cos once (fast)
const sinT = new Float32Array(theta.length);
const cosT = new Float32Array(theta.length);
for (let i = 0; i < theta.length; i++) {
    sinT[i] = Math.sin(theta[i]);
    cosT[i] = Math.cos(theta[i]);
}
try{
ws.onmessage = (e) => {
    const data = JSON.parse(e.data);

    const r = decodeBase64ToInt16Array(data.r);
    const yaw = data.yaw ?? 0.0;
    const tof = data.tof ?? 0.0;

    // Safety: handle mismatch if lidar changes resolution
    const n = Math.min(r.length, sinT.length);

    // yaw rotation scalars
    const cosYaw = Math.cos(yaw);
    const sinYaw = Math.sin(yaw);

    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.save();
    ctx.translate(canvas.width / 2, canvas.height / 2);

    /* ---------- Grid ---------- */
    const circleStepMM = 100; // 10 cm
    const circleCount = 30;

    ctx.strokeStyle = "#333";
    ctx.lineWidth = 1;

    for (let i = 1; i <= circleCount; i++) {
        const r = i * circleStepMM * scale;
        ctx.beginPath();
        ctx.arc(0, 0, r, 0, Math.PI * 2);
        ctx.stroke();

        if (i % (circleCount / 3) === 0){
        // distance label
        ctx.fillStyle = "#777";
        ctx.font = "10px monospace";
        ctx.fillText(`${i * 10} cm`, r + 2, 0);
        }
    }
    // Lidar FOV (270°)
    ctx.strokeStyle = "#444";
    ctx.lineWidth = 1;

    const fovMin = -135 * Math.PI / 180;
    const fovMax =  135 * Math.PI / 180;
    const fovRadius = 1500 * scale;

    ctx.beginPath();
    // left line
    ctx.moveTo(0, 0);
    ctx.lineTo(
    Math.sin(fovMin) * fovRadius,
    -Math.cos(fovMin) * fovRadius
    );
    ctx.stroke();

    // right line
    ctx.beginPath();
    ctx.moveTo(0, 0);
    ctx.lineTo(
    Math.sin(fovMax) * fovRadius,
    -Math.cos(fovMax) * fovRadius
    );
    ctx.stroke();
    /* ---------- Axes (Axis) ---------- */
    ctx.strokeStyle = "#555";
    ctx.beginPath();
    ctx.moveTo(-canvas.width / 2, 0);
    ctx.lineTo(canvas.width / 2, 0);
    ctx.stroke();

    ctx.beginPath();
    ctx.moveTo(0, -canvas.height / 2);
    ctx.lineTo(0, canvas.height / 2);
    ctx.stroke();

    /* ---------- LIDAR Points ---------- */
    ctx.fillStyle = "#00ff88";
    for (let i = 0; i < n; i++) {
    const ri = r[i]; // mm

    // x = -(sin(theta+yaw))*r
    // y =  (cos(theta+yaw))*r
    // sin(theta+yaw)=sinT*cosYaw + cosT*sinYaw
    // cos(theta+yaw)=cosT*cosYaw - sinT*sinYaw
    const sinW = sinT[i] * cosYaw + cosT[i] * sinYaw;
    const cosW = cosT[i] * cosYaw - sinT[i] * sinYaw;

    const x = (-sinW * ri) * scale;
    const y = ( cosW * ri) * scale;

    ctx.fillRect(x, -y, 2, 2);
    }
    // Draw ToF point on lidar pov
    ctx.fillStyle = "#00eaff";
    const tofY = (tof + 30) * scale * 10; // assuming tof[0] is the distance in mm and the 30 is an offset to place it correctly on the canvas comparing distance of the tof and the lidar
    ctx.beginPath();
    ctx.arc(0, tofY, 5, 0, Math.PI );
    ctx.fill();
    ctx.restore();
};
}catch(e){
    console.error("Error in LIDAR WS onmessage:", e);
}

</script>

</body>
</html>
